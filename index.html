<!DOCTYPE html>
<html>
<head>
    <title>VR Archery Game</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100%; }
    </style>
</head>
<body>
    <!-- Load Three.js -->
    <script src="https://threejs.org/build/three.js"></script>
    <!-- Load Ammo.js (asm.js version) -->
    <script src="https://cdn.jsdelivr.net/gh/kripken/ammo.js/builds/ammo.js"></script>
    <script>
        // VRButton module for WebXR (simplified for this example)
        const VRButton = {
            createButton: function(renderer) {
                const button = document.createElement('button');
                button.textContent = 'ENTER VR';
                button.style.position = 'absolute';
                button.style.bottom = '20px';
                button.style.right = '20px';
                button.onclick = function() {
                    renderer.xr.enabled = true;
                    navigator.xr.requestSession('immersive-vr').then(session => {
                        renderer.xr.setSession(session);
                    });
                };
                return button;
            }
        };

        // Physics world setup using Ammo directly (asm.js version)
        const collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
        const dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
        const overlappingPairCache = new Ammo.btDbvtBroadphase();
        const solver = new Ammo.btSequentialImpulseConstraintSolver();
        const physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
        physicsWorld.setGravity(new Ammo.btVector3(0, -9.8, 0));

        // Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 0); // Player height
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Enable WebXR
        renderer.xr.enabled = true;
        document.body.appendChild(VRButton.createButton(renderer));

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(0, 10, 10);
        scene.add(directionalLight);

        // Bow
        const bowGeometry = new THREE.BoxGeometry(0.1, 1, 0.1);
        const bowMaterial = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
        const bow = new THREE.Mesh(bowGeometry, bowMaterial);
        scene.add(bow);

        // Arrow
        const arrowGeometry = new THREE.CylinderGeometry(0.01, 0.01, 1, 8);
        const arrowMaterial = new THREE.MeshBasicMaterial({ color: 0xA9A9A9 });
        let arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
        arrow.position.set(0, 0, -0.5); // Relative to bow
        scene.add(arrow);
        let arrowBody = null;

        // Target
        const targetGeometry = new THREE.CircleGeometry(1, 32);
        const targetMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
        const target = new THREE.Mesh(targetGeometry, targetMaterial);
        target.position.set(0, 1.5, -10); // 10 meters away
        scene.add(target);
        const targetShape = new Ammo.btSphereShape(1);
        const targetBody = new Ammo.btRigidBody(
            new Ammo.btRigidBodyConstructionInfo(
                0, // Mass (0 for static)
                new Ammo.btDefaultMotionState(
                    new Ammo.btTransform(
                        new Ammo.btQuaternion(0, 0, 0, 1),
                        new Ammo.btVector3(0, 1.5, -10)
                    )
                ),
                targetShape,
                new Ammo.btVector3(0, 0, 0)
            )
        );
        physicsWorld.addRigidBody(targetBody);

        // VR Controllers
        const controller1 = renderer.xr.getController(0); // Left hand (bow)
        const controller2 = renderer.xr.getController(1); // Right hand (string)
        scene.add(controller1);
        scene.add(controller2);

        let isPulling = false;
        let pullStartPosition;

        controller2.addEventListener('selectstart', () => {
            if (!arrowBody) {
                isPulling = true;
                pullStartPosition = controller2.position.clone();
                arrow.position.copy(controller2.position);
            }
        });

        controller2.addEventListener('selectend', () => {
            if (isPulling && !arrowBody) {
                isPulling = false;
                const pullDistance = controller2.position.distanceTo(pullStartPosition);
                launchArrow(pullDistance, controller2.getWorldDirection(new THREE.Vector3()));
            }
        });

        function launchArrow(pullDistance, direction) {
            const k = 250; // Spring constant (N/m), approximated from 40lb bow
            const m = 0.025; // Arrow mass (kg)
            const v = Math.min(Math.sqrt((k * pullDistance * pullDistance) / m), 71); // Cap at realistic speed
            const velocity = direction.clone().multiplyScalar(-v); // Negative for forward

            // Create physics body for arrow
            const transform = new Ammo.btTransform();
            transform.setIdentity();
            transform.setOrigin(new Ammo.btVector3(arrow.position.x, arrow.position.y, arrow.position.z));
            const motionState = new Ammo.btDefaultMotionState(transform);
            const shape = new Ammo.btCapsuleShape(0.01, 1);
            const localInertia = new Ammo.btVector3(0, 0, 0);
            shape.calculateLocalInertia(m, localInertia);
            const rbInfo = new Ammo.btRigidBodyConstructionInfo(m, motionState, shape, localInertia);
            arrowBody = new Ammo.btRigidBody(rbInfo);
            arrowBody.setLinearVelocity(new Ammo.btVector3(velocity.x, velocity.y, velocity.z));
            arrowBody.setLinearDamping(0.1); // Simulate air resistance
            physicsWorld.addRigidBody(arrowBody);

            // Reset arrow after 5 seconds or collision
            setTimeout(() => {
                if (arrowBody) {
                    physicsWorld.removeRigidBody(arrowBody);
                    Ammo.destroy(arrowBody);
                    arrowBody = null;
                    scene.remove(arrow);
                    arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                    arrow.position.set(0, 0, -0.5);
                    scene.add(arrow);
                }
            }, 5000);
        }

        // Sync physics with visuals
        function updatePhysics() {
            physicsWorld.stepSimulation(1 / 60, 10);
            if (arrowBody) {
                const transform = new Ammo.btTransform();
                arrowBody.getMotionState().getWorldTransform(transform);
                const pos = transform.getOrigin();
                arrow.position.set(pos.x(), pos.y(), pos.z());
                const quat = transform.getRotation();
                arrow.quaternion.set(quat.x(), quat.y(), quat.z(), quat.w());
            }
        }

        // Collision detection
        function checkCollisions() {
            if (!arrowBody) return;
            const manifolds = dispatcher.getNumManifolds();
            for (let i = 0; i < manifolds; i++) {
                const manifold = dispatcher.getManifoldByIndexInternal(i);
                const body0 = manifold.getBody0();
                const body1 = manifold.getBody1();
                if ((body0 === arrowBody && body1 === targetBody) || (body1 === arrowBody && body0 === targetBody)) {
                    const numContacts = manifold.getNumContacts();
                    if (numContacts > 0) {
                        const point = manifold.getContactPoint(0).get_m_positionWorldOnA();
                        const hitPos = new THREE.Vector3(point.x(), point.y(), point.z());
                        const distanceFromCenter = hitPos.distanceTo(target.position);
                        const score = Math.max(0, 10 - Math.floor(distanceFromCenter * 10));
                        console.log(`Score: ${score}`);
                        physicsWorld.removeRigidBody(arrowBody);
                        Ammo.destroy(arrowBody);
                        arrowBody = null;
                        scene.remove(arrow);
                        arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                        arrow.position.set(0, 0, -0.5);
                        scene.add(arrow);
                        break;
                    }
                }
            }
        }

        // Render loop
        function animate() {
            renderer.setAnimationLoop(() => {
                updatePhysics();
                checkCollisions();

                // Update bow position
                bow.position.copy(controller1.position);
                bow.quaternion.copy(controller1.quaternion);

                if (isPulling && !arrowBody) {
                    arrow.position.copy(controller2.position);
                } else if (!arrowBody) {
                    arrow.position.copy(bow.position).add(new THREE.Vector3(0, 0, -0.5).applyQuaternion(bow.quaternion));
                    arrow.quaternion.copy(bow.quaternion);
                }

                renderer.render(scene, camera);
            });
        }
        animate();
    </script>
</body>
</html>
